# 使い方

このプログラムはただ実行するだけでいい

# 答え合わせ

ここで，`Train-4` と `Train-5` の答え合わせをしていく．

## Train-4

結論を言うと以下の通り．必ずしも一致している必要はなく，光らせた結果意図した文字に見えるように光ればそれで正解

```c
uint8_t NUM0 = 0b11111100;
uint8_t NUM1 = 0b01100000;
uint8_t NUM2 = 0b11011010;
uint8_t NUM3 = 0b11110010;
uint8_t NUM4 = 0b01100110;
uint8_t NUM5 = 0b10110110;
uint8_t NUM6 = 0b10111110;
uint8_t NUM7 = 0b11100100;
uint8_t NUM8 = 0b11111110;
uint8_t NUM9 = 0b11110110;
```

## Train-5

```c
int array_2[10] = {83, 287, 65, 492, 836, 567, 0, 445, 31, 768};
```

問①

```c
array_2[3]
```

この配列のインデックスは `3` ということで，左から 4 つ目の値が選択される．よって，`492` が正解

問②

`445` が出てくるのは 8 番目なのでインデックスの値は 1 を引いて `7` が正解

# 説明

本コードでは，`uint8_t` 型で `num_to_bin` という配列を作り，値とともに初期化している  
なお，16 進数に対応できるよう，ついでに `A` ~ `F` も作っている

`setup()` 関数内では，2 つの初期化用関数 `GPIO_init()` と `LED_init()` がコールされている．これらはその下で定義されているもので，元々 `setup()` 関数内で直接実行されていたもののラッパーである．初期化処理は関数化しておくとどこで何のための処理をしているのかわかりやすくなる

## for 文

`loop()` 関数内で実行されている `for` 文について，おそらく初出なので詳しめに解説しておく

`for` 文は，`while` 文と同じように，繰り返し処理をするための制御文だが，「決まった回数繰り返す」ということに向いている．一方の `while` は「特定の条件を満たしている間」というように，やや性質がことなる（が，工夫すれば全く同じことができる）

`while` 文は，丸カッコ `()` の中に入るのは条件式一つだけだったが，`for` 文はセミコロン `;` 区切りで 3 つ記述する必要がある．順に説明していく  
なお，便宜上，第一・第二・第三記述欄と呼称する

### 第一記述欄

`for` 文では，カウンタ変数（ほとんどの場合 `i`）を用いて繰り返し処理を行う．その変数 `i` の初期化を行うのが第一記述欄である．ANSI C 系の場合は途中で変数を新たに宣言することができないが，Arduino は C++ ベースなので第一記述欄で直接変数を宣言できるので， `size_t i = 0` のように記述することが多い．なお，型は `size_t` が最適とされる．`size_t` はアーキテクチャによってビット数が変わる整数型である

### 第二記述欄

ここで何回繰り返すかを決める．条件式を用いて回数を指定し，`i < N`（`N` は回数）とすると N 回繰り返すことになる．条件式を見ればわかるが，`i < N` なので `i` は `N - 1` まで増加する．ここで，`i` は `0` から始まるので，結果として N 回のループとなるのである

ところが本コードでは，見慣れない書き方をしている．`sizeof()` とはなんぞや

話は少し脇にそれるが，`for` 文と配列はとても相性が良いことが知られている．なぜなら，配列を用意して，その配列のサイズだけ繰り返すという処理をすれば，その配列全体について所望の処理を行うことができるからである  
たとえば，配列の要素すべてを二倍するなど．そんな単純な処理をするシーンがあるとは思えないが，まぁ一例として

話をもとに戻すと，`sizeof()` は C 言語で用意されている機能で，引数として渡した変数（配列を含む）の大きさが何バイトかを返してくれる便利なものである．配列 `num_to_bin` の型は `uint8_t` つまり 8bit 幅の非負整数であり，要素数がそのままバイト数になるので，配列をそのまま `sizeof()` に渡すだけで要素数を返してくれる．なんと便利なことか  
なお，一般に配列の要素数を `sizeof()` で調べたい場合，以下のようにするのが良い

```c
int size = sizeof(array) / sizeof(array[0]);
```

今回の場合，配列 `num_to_bin` は 16 個の要素を持っており，かつ `uint8_t` 型なので，返ってくる値は `16` となる．つまり，この `for` 文は 16 回繰り返されるということになる

### 第三記述欄

ここはカウンタ変数をどう扱うかを記述する．ほとんどの場合 `i++` や `i += 1` のように単純に 1 インクリメント（加算）させるだけだが，稀にデクリメント（減算）させたり，偶数だけ扱いたいときのようなシーンでは `i += 2` とすることもある．ここはケースバイケースだが，単純に決まった回数繰り返したいのであれば `i++` とおぼえておけばよい

---

このようにして `for` 文を使うわけだが，本コードではどのような挙動をするか，考えてみよう

先述の通り，`sizeof(num_to_bin)` は `16` を返すので，16 回繰り返されることになる．その際，繰り返されるごとに `i` の値は 1 づつ増えていく  
このことを頭に入れておけば，その下で何が起きるか，ある程度想像できるだろう

まず最初のループでは，　`i` は `0` なので，`num_to_bin[i]` は `0b11111100` を返す．これを直接 `LED_OUT()` に渡すことで，0 に見える文字が光る  
次のループでは，`i` はインクリメント演算子により `1` となるので`num_to_bin[i]` は `0b01100000` を返す．これを `LED_OUT()` に渡すことで，今度は 1 に見える文字が光る

あとはこれの繰り返しである．このように，配列と `for` 文はかなり相性がいいので覚えておくと便利

その下の `delay(500)` は 500 ミリ秒待つという処理である．これにより，大体 2Hz で数字が更新される．精度は必要でないので `delay()` 関数で十分
