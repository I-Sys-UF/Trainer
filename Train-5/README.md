# 使い方

1. とりあえず書き込んで動かしてみる
2. `INDEX` の値を任意に変えて実行してみる

# 説明

ここでは配列を取り扱う．配列とは，同じ型の値を，メモリの許す限り並べてひとあつめにしたもので，任意の型に適応できる．やり方は簡単．変数名の後ろに角カッコ `[]` を付けるだけ．この角カッコは任意数付けることができ，1 つの場合を一次元配列，2 つの場合を二次元配列．．．と呼ぶ  
一般には二次元配列くらいまでは使うが，三次元以上を使うのは稀であろう

## 配列について

本プログラムでは，`uint8_t` 型の配列 `array` を，値とともに初期化している．本来，角カッコの中には配列の要素の数（要素数）を記述する必要があるが，値とともに初期化する場合はコンパイラがその要素数を数えて補完してくれる．なお，要素数以上の数であれば併記しても差し支えない

以下のような宣言はすべて有効である

```c
uint8_t array_1[10];
uint8_t array_2[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
uint8_t array_3[10] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
uint8_t array_4[20] = {0, 1, 2, 3};
```

## 文字列

`char` 型の配列のみ別名があり，文字の配列ということで文字列と呼ぶ．以下のような宣言方法がある．なお，文字列は終わりを表すためにヌル文字 `\0` を挿入する必要があるため，配列のサイズは要素数 + 1 となる  
初期化時にヌル文字を挿入する必要は特になく，コンパイラが補完してくれる．もちろん明示的に記述して宣言してもいい

```c
char string_1[] = "Arduino";
char string_2[10] = "Arduino";
char string_3[10] = {'A', 'r', 'd', 'u', 'i', 'n', 'o'};
char string_4[10];
```

ただし，このようなことはできない

```c
char string[10];
string = "Arduino";
```

このようなことをしたい場合は，`sprintf()` 関数が便利

```c
char string[10];
sprintf(string, "%s", "Arduino");
```

注意点として，「文字」はシングルクォーテーション `'` で囲み，「文字列」はダブルクォーテーション `"` で囲む必要がある．一文字しかなかったとしてもダブルクォーテーション `"` で囲めばそれは文字列であり，末尾にヌル文字 `\0` が付加される

# 配列の使い方

ここに，一つの配列を宣言する．

```c
uint8_t array[10] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
```

これは本コードでも使用されている配列である

配列として宣言された値は，インデックスと呼ばれる値を使って呼び出すことができる．インデックスとなりうる値は `0` ~ `要素数 - 1` の範囲で，`0` スタートなので最大値は `要素数 - 1` になる．なお，この範囲を超えた値をインデックスに指定してしまうと，メモリ上に展開されているデータの，配列に関係ないところを読み出してしまい，バグの原因となるので注意．C 言語は低級言語なので，その辺のケアはしてくれない

以下の条件式は `true` である

```c
(array[5] == 5)
```

この配列 `array` は，インデックスと，インデックスに対応する要素の値が一致するように作られているので本質的には意味がないが，インデックスとの対応がわかりやすいものである

ここで問題．以下の配列を宣言する

```c
int array_2[10] = {83, 287, 65, 492, 836, 567, 0, 445, 31, 768};
```

問①：以下の値は何になるか

```c
array_2[3]
```

問②：`array_2[x]` の値は `445` であった．`x` に当てはまる数字は何か
